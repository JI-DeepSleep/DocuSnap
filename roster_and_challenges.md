#  Team Roster and Individual Contribution

## Zijun Yang

His primary contributions to the project included serving as project manager, handling server development, and conducting extensive debugging of the app's backend. As **project manager**, he took ownership of task assignment, app design, feasibility analysis, workload breakdown, and progress tracking. His strategic approach to parallel task delegation enhanced development efficiency, allowing the team to deliver a highly refined application. As the **sole server developer**, he designed and implemented all [server code](https://github.com/JI-DeepSleep/DocuSnap-Backend), which incorporated LLM prompt engineering for all core features, a cache system, an OCR system, security protocols, and an asynchronous request-response model. Completing the server ahead of schedule facilitated smoother app development. In mid-July, he dedicated significant effort to **debugging the app backend**â€”removing mockup data, connecting the app database with the UI, fixing the encryption/decryption and codec module, redesigning the database schema to enable image storage, and ensuring seamless integration of all submodules.

## Jingjia Peng

## Ziming Zhou

## Minyang Qu

His core contribution was developing the geometric processing module in pure Kotlin for Android, enabling document standardization for downstream analysis. He implemented a custom automatic corner detector, designed an interactive manual adjustment interface with draggable corners, and built the perspective correction pipeline. This self-contained module formed the foundation for all document preprocessing in the application while optimizing for mobile performance constraints.

## Huijie Tang

# Challenges

**LLM prompts present a key challenge.** The issues we faced include handling JSON escapes, enforcing the desired JSON structure, preventing extraneous outputs (e.g., "Here's the results of xxx"), and unifying date formats and field names. We built a web mockup for rapid, iterative engineering and tested it on about 20 samples after numerous refinements.  **A key part of our server design is security.** The first version of our server did not use AES. We struggled quite a bit to get RSA and Base64 working. However, performance traces showed that RSA was far too slow for encrypting the payload, so we refactored the entire server and API spec to adopt the current RSA + AES hybrid encryption for both security and performance. This also took a significant amount of time to set up correctly.  **Another performance bottleneck was OCR speed.** This is why we did not opt for a VPS but instead purchased an Orange Pi 5 Pro, which is much more performant. The server is in Zijun's dormitory, and it took considerable effort to expose the service to the internet and configure all the web settings properly. To enable encryption of the app's database and prevent users from modifying imported images in the gallery, we decided to **store images as Base64-encoded strings in the database**. This approach is significantly more complex than the default URI-based image storage provided out-of-the-box, and it requires substantial effort to properly implement reading and writing images from the database. During early UI development before the app's database was ready, we used mock data which later created **challenges when implementing dynamic content with complex control flows**. The control logic proves especially intricate due to background LLM tasks that should trigger UI updates upon receiving results. Furthermore, supporting editing and deletion functionality significantly increases both the complexity and development time of the control logic.

Implementing robust **corner detection** without third-party libraries presented significant hurdles due to imperfect outputs from the self-developed image processing pipeline. The **Canny-style edge detector** frequently generated **discontinuous edges** under challenging lighting conditions, while the **contour finder** produced **irregular polygons** contaminated with noise points. To address these limitations, he designed a **novel corner detection algorithm** that first calculated the contour's **centroid** by averaging all edge points, then identified the initial corner as the point with **maximum distance** to this centroid. The second corner was selected through **maximum distance** measurement to the first corner, while the final corners were determined by finding points with **extreme perpendicular distances** relative to the line connecting the initial corners. This approach demonstrated superior **robustness** to fragmented edges and irregular contours compared to conventional **polygon approximation** methods.